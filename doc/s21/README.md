s21 暗黙の型変換とパラメーター
================

### 概要
- 冗長なコードを簡略化するための暗黙の処理を行わせる機能がある
    - 暗黙の型変換
    - 暗黙のパラメーター
    - 可視境界
- 暗黙な処理が意図せずに行われないために、色々制約がある

- クラスを拡張する方法

暗黙の型変換
--------

- 型キャストみたいな物
- 例: イベントリスナー
- 関数をそのまま渡したい

implicit の規則
--------

- マーキングルール: implicit がついた定義だけが暗黙の型変換(とパラメーター)に使われる
    - 関数、変数、オブジェクト定義で使える
- スコープルール: 暗黙の型変換の検索にはスコープが制限される
    - 単一の識別子としてスコープ内にある場合
        - ×: some.convert(x)、○: convert(x)
        - 同一ファイル内にある場合
        - import を(直接、もしくはxx._で)している場合
            - import Preamble._ と呼ぶためにPreambleクラスを用意することが多い
- コンパニオンオブジェクトのメソッドである場合
    - 変換元でも変換先でも
- 一度に一回ルール: 暗黙の型変換が二重に挿入されることは無い
    - この制限の回避方法あり
- 明示的変換優先ルール: 書かれた状態で動作する場合は暗黙の型変換を行わない
- (非曖昧性ルール: 他に起こりうる暗黙の型変換が無い場合のみ型変換が行われる)
    - オンラインの原文にのみ記載、削除された?
    - …と思ったら拡張されて後述されている

### 暗黙の型変換の名前の付け方
- 何でも良い
    - (Predef では byte2float などが定義されている)
- 名前が問題となるケース
    - 直接呼び出す時
    - 名前を指定して import したい時

### implicit が行われる場所
- 要求された方への変換
- レシーバの変換
- 暗黙のパラメーター

要求された型への暗黙の型変換
--------

- 各数値型の(より大きい数値型への)暗黙の型変換はPredefに含まれている

レシーバの変換
--------

- 例: Intから自作有理数クラスへの変換
- 例: -> 演算子
- 該当メソッドを実装した変換が複数ある場合はどうする??

暗黙のパラメーター
--------

- 関数の引数を補完する
- カリー化されたパラメーターリスト全体
    - カリー化されてなくてもうまくいった…
- 変数定義にimplicitをつける

- 型パラメーターを使った暗黙のパラメーターも使用できる
    - 例: orderer
    - 標準ライブラリは基本的な型の orderer を提供している
    - (関係している型のコンパニオンオブジェクトの定義もみる)

### 暗黙のパラメーターのためのスタイルの原則
- 意図せずに使用されないように、パラメーターの型は特別な物を使う
    - String などをimplicitの型にしない
    - (T, T) => Boolean ではなく Ordering を使う

可視境界
--------
- implicit なパラメーターがメソッド内部で暗黙の型変換や暗黙のパラメーターに使われる事が多い
- implicit なパラメーターが直接参照されない事も多い
- 可視境界を使ってメソッド定義を小さくできる
- 「T &lt;% Ordered[T]」は「Ordered[T]として扱える任意のT」と読める

複数の型変換を適用できる時
--------

- 基本的には適用しない
- 片方がより厳密な型を使った変換ならそれを使う(2.8以降)
    - サブクラスのメソッドを優先する
    - 引数の方がサブクラスになっている

暗黙の型変換のデバッグ
--------

- 見つけられない場合
    - 型変換を明示的に書いてみる
- scalac -Xprint:typer
- scala -Xprint:typer
