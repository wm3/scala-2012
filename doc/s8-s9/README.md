s8 関数とクロージャー
========

## この章の概要

1. いわゆる「関数型スタイル」のプログラミングが出来る
2. 関数定義の様々な短縮形がある

## メソッド (省略)

## ローカル関数
* ローカル関数のメリット: 名前空間を汚さない、関数のスコープが小さくなる
* 使用例: リスト8.2 (processLine)
  * 外のローカル変数も使える

## ファーストクラスの関数
* 関数リテラル
  * (varName: Type, ...) => { ... }
* 短縮形1: 本文の中括弧の省略
  * 本文が単文の場合: (varName: Type, ...) => { x + y * 3 }
  * (varName: Type, ...) => x + y * 3
* Scala の標準ライブラリは関数オブジェクトを渡すために作り込まれている
  * 一例として コレクションの foreach、 filter

## 関数リテラルの短縮形
* 短縮形2: 引数の型の省略
  * コンパイラが引数の型をうまく推論してくれた場合: arr.filter((x: Int) => x > 0)
  * arr.filter((x) => x > 0)
* 短縮形3: 型パラメーターの括弧の省略
  * 短縮形2が出来た場合のみ(その上で引数が一つの時かな?)
  * arr.filter(x => x > 0)
* 型推論はどういう時に出来る?
  * 考えないで良い。まずは普通の形で書いて、その後省略してみる。
  * そのうち慣れる!

## プレースホルダー構文
* 短縮形4: プレースホルダーの使用1
  * 引数が一つ、かつ型推論してくれる場合: arr = Array(1, -2, 3)
  * arr.filter(_ > 0)
* 短縮形5: プレースホルダーの使用2
  * 型推論できなかった場合: arr = Array[Any](1, -2, 3)
  * arr.filter((_: Int) > 0)
* 短縮形6: プレースホルダーの使用3
  * 引数が複数ある場合: arr.reduce((x, y) => x + y)
  * arr.reduce(_ > _)

## 部分適用された関数
* 短縮形7: 引数リスト全体のプレースホルダー
  * 一引数以外の関数: def max(x: Int, y: Int) { ... }
  * arr.reduce(max _)
  * 0引数の関数でもOK
* 短縮形8: プレースホルダーの省略
  * うまく推論してくれる場合
  * arr.reduce(max)
  * println(max) とかはできない。printlnの引数は関数とは限らないため。
* ちなみに: (max _)は呼び出すたびに違うhashCode()を返した。

## クロージャー
* (x: Int) => x + more の more って何が入る? という話
  * 正直、使う際にはあまり考えなくても良いと思う
  * JavaScript と同じ
  * (他の挙動をする言語(Lispとか)を使った事がないです…)

## 関数呼び出しの特殊な形態
* 連続パラメーター
  * Java の可変長引数: def echo (args: String*) = args.foreach(println)
  * Java と違って配列は渡せない: echo(Array("a", "b")) はエラー
    * echo(Array("a", "b"): _*) でJavaの同様のことができる
* 名前付き引数
  * 例: def speed(distance: Float, time: Float) = ...
  * speed(100, 10) でも speed(distance = 100, time = 10)でもOK
* パラメーターのデフォルト値
  * 例: def printTime(out: java.io.PrintStream = Console.out) = ...
  * 名前付引数と併用すると良い

## 末尾再帰
* 知ってる人は知っている、知らない人は知らなくても良い
* 末尾再帰を最適化してくれる
  * ただしJVMの制約のため、ごく単純なもののみ
  * 相互呼び出しや関数オブジェクト呼び出しでは出来ない
* clojure はrecかなんかをつけないと行けなかったけど、なぜだろう

## 感想
* 良くも悪くも短縮形が多い。
* There is more than one way to do it 寄り。これはJavaと大きく異なる。


s9 制御の抽象化
===========

## この章の概要

1. 関数オブジェクトでコードが簡単になる!
2. (擬似的に)新しい制御構文を作る方法


## 重複するコードの削減
* (例: FileMatcher をクラスを作ってみましたので参照)

## クライアントコードの単純化
* コレクションのループ系のメソッド(foreach, map, filter, find, reduce, groupBy, zip ...)
* P.174 下と P.175 上を比較

## (新しい制御構造)
* (例: 自動で stream を close() する書き込みメソッドを書きましたので参照)

## カリー化
* 要するに def doSomething(x: ...)(y: ...)(z: ...) という表記がある、ということ
  * 目的の60%くらいは次節の制御構文っぽい呼び出しのためのもの
  * 残りの30% くらいは暗黙の引数のためのもの
* 後述する「制御構文の擬似的な拡張」を実現するための物(他に目的はある??)

### ちなみに: カリー化について(憶測が混じっています)
* 元々は計算機科学の理論的な分野の概念
* 偉い学者: 「関数の引数が一つだったり二つだったりすると難しい!」
  * 「だから、複数の引数を用意する代わりに関数を返す関数にしよう!」
  * ラムダ計算とかがそれ。
* 関数の引数が二つ以上無い言語もある(Haskell)
* 疑問: Scala は本当に「カリー化」?
  * 関数を返す関数は作っているし極めて近いが…
  * 「変換」なのだろうか? これが分かりにくい原因のようにも見える。
* ちなみに: カリー化(scala) vs ブロック引数定義のための構文(ruby)
  * 呼び出す分には両方とも同じ
  * 定義方法が違う

## 新しい制御構造を作る
* 引数が一つの場合、f(x) の代わりに f { x } と書ける

## 名前渡しパラメーター
* assert や && を実現するための機能
* リスト9.5 参照
